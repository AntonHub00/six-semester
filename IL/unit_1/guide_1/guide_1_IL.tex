\documentclass{article}

%Configuraciones de idioma del documento
\usepackage[spanish]{babel}
%Configurar entrada {usar caracteres desde el teclado como á}
\usepackage[utf8]{inputenc}
%Fuente que pueda renderizar caracteres en nuestro idioma
\usepackage[T1]{fontenc}
%Fuente compatible
\usepackage{lmodern}

\usepackage{graphicx}

\begin{document}

\title{Guía de Lenguajes de Interfaz}
\author{Antonio Emiko Ochoa Adame}
\maketitle

\section{Importancia del lenguaje Ensamblador}

Si se entiende el lenguaje ensamblador se pueden hacer programas eficientes porque
puede ver qué se está programando y relacionarlo con ensamblador.

\vspace{1em}
Esto es fácil de ver en lenguajes de medio nivel (como C) donde es fácil de
apreciar cómo sería dicho código, pero en ensamblador.

\section{Lenguaje Máquina}

Es el lenguaje que entiende el procesador, es decir, unos y ceros (1s y 0s).

\section{Lenguaje Ensamblador}

Es el lenguaje que es más fácil de entender para el programador.

El lenguaje ensamblador está basado en \textbf{nemónicos}.

\vspace{1em}
Aprender el código de cada intrucción es muy complicado para el programador, así
los \textbf{nemónicos} son usados en su lugar.

\vspace{1em}
\textbf{Nemónicos}.- Palabras cortas que dan una idea de la instrucción.

\vspace{1em}
Ejemplos de \textbf{nemónicos}: ADD (suma), LD (cargar), sub (restar).

\vspace{1em}
\textbf{OPCODE (Código de operación)}.- Lenguaje que entiende el procesador e
indica la instrucción a realizar.

\vspace{1em}
Dos procesadores son \textbf{compatibles} (equivalentes) si tiene el
\textbf{mismo número de instrucciones} y el \textbf{mismo OPCODE para la misma
intrucción}.

\newpage

\section{Memorias}

\begin{itemize}
	\item
		Secuencial
	\item
		No secuencial
	\item
		Volátil
	\item
		No volátil (ROM)
\end{itemize}

\subsection{Clasificación de memorias}

\subsubsection{Memoria secuencial y no secuencial}

Para acceder a una determinada posición de una localidad un una memoria secuencial
, es necesario pasar por las localidades adyacentes.

\vspace{1em}
Ejemplos: Cassettes (se tenía que rebobinar).

\vspace{1em}
\textbf{¿Cómo funcionan las memorias actuales?}

\vspace{1em}
Tienen un bus de direcciones donde se indica la localidad a accesar (no secuencial).

\subsubsection{Memoria volátil y no volátil}

\textbf{Memoria volátil}.- La información se mantiene siempre y cuando esta se
mantenga energizada; La información se pierde si se elimina el voltaje.

\vspace{1em}
\textbf{Memoria no volátil}.- La información se mantiene aún sin voltaje.

\subsubsection{Memoria estática y dinámica}

La memoria \textbf{RAM} se divide en:

\begin{itemize}
	\item
		Estática $\rightarrow$ utiliza \textbf{transistores}
	\item
		Dinámica $\rightarrow$ utiliza \textbf{capacitores}
\end{itemize}

\vspace{1em}
\textbf{Memoria estática}

\vspace{1em}
Mientras se encuentre energizada la información se mantiene.

\vspace{1em}
Está basada en transistores.

\vspace{1em}
\textbf{Memoria dinámica}

\vspace{1em}
Además de estar energizada, se requiere refrescar la información para no perderla.

\vspace{1em}
Está basada en capacitores. Un capacitor pierde su carga con el tiempo.

\vspace{1em}
El sistema operativo es el encargado de leer y escribir a información de esta
memoria; esto se hace cientos de veces por segundo.

\vspace{1em}
Bit en una memoria dinámica:

\begin{figure}[h!]
	\includegraphics[width=\linewidth]{bit_refresh.jpeg}
	\caption{Refresco de bit}
	\label{fig:bit_refresh}
\end{figure}

En la figura \ref{fig:bit_refresh} se puede observar cómo el sistema operativo
lee el bit de información y lo vuelve a escribir.

\subsection{Memoria ROM}

\begin{itemize}
	\item
		EPROM
	\item
		E$^2$PROM
	\item
		Flash
\end{itemize}

\subsubsection{Memoria EPROM (Programable eléctricamente)}

Solo puede programar bits en un cambio de \textbf{1 a 0}, pero \textbf{no} puede convertir de
\textbf{0 a 1}

\vspace{1em}
\textbf{Proceso de borrado}.- Poner los bits en 1. (se borra con luz UV).

\vspace{1em}
Se caracteriza por tener una ventan de cuarzo transparente para que la luz UV
pueda entrar y así borrar la información (poner los bits en 1).  Posteriormente,
con un programador se ponen los bits deseados a 0.

\vspace{1em}
En las PCs antiguas, el BIOS tenía una memoria EPROM donde se cubría la ventana
con cinta negra para evitar la luz UV.

\subsubsection{Memoria E$^2$PROM (Programable y borrable eléctricamente)}

\vspace{1em}
Con el mismo programador se pueden poner los bits a 0 y a 1 (borrar).

\vspace{1em}
Cualquier localidad de memoria puede programarse de manera individual.

\subsubsection{Memoria Flash}

Es muy parecida a la E$^2$PROM porque puede borrarse y programarse de manera
elétrica.

\vspace{1em}
Permite mayor densidad de información.

\vspace{1em}
Es más económica.

\vspace{1em}
\textbf{Desventaja}:

\vspace{1em}
No se puede programar una localidad de manera independiente; se tiene programar
un \textbf{bloque (o página)} completo.

\vspace{1em}
Ejemplo de cómo se modifican las memorias:

\begin{figure}[h!]
	\includegraphics[width=\linewidth]{e2prom.jpeg}
	\caption{Memoria E$^2$PROM}
	\label{fig:e2prom}
\end{figure}

En la figura \ref{fig:e2prom} se muestra cómo simplemente se modifica la localidad
deseada sin ningún problema.

\begin{figure}[h!]
	\includegraphics[width=\linewidth]{flash.jpeg}
	\caption{Memoria Flash}
	\label{fig:Flash}
\end{figure}

\newpage

En la figura \ref{fig:Flash} se muestra cómo es el proceso de escribir en este
tipo de memoria; hay tres pasos:

\begin{enumerate}
	\item
		Se leen 512 bytes
	\item
	Se modifica la localidad deseada
	\item
		Se escribe el bloque completo (los 512 bytes)
\end{enumerate}

\section{Arquitectura de un procesador}

\begin{figure}[h!]
	\includegraphics[width=\linewidth]{architecture.jpeg}
	\caption{Arquitectura de un procesador}
	\label{fig:Archi}
\end{figure}

A continuación se explica la arquitectura de un procesador como se muestra en la
figura \ref{fig:Archi}:

\vspace{1em}
La ROM guarda tanto las intrucciones como las constantes.

\vspace{1em}
La RAM guarda variables.

\vspace{1em}
Los operandos de la ALU pueden ser variables, constantes y registros, pero siempre
uno de los operando debe ser un \textbf{registro}.

No se pueden hacer operaciones con 2 variables, 2 constantes o una variables y
una constante.

\vspace{1em}
La ALU decodifica la instrucción. Cada instrucción tiene asociado un
\textbf{OPCODE} (Código de operación), cuando la ALU detecta el \textbf{OPCODE},
sabe qué operación debe realizar con los operandos.

\vspace{1em}
Cuando se hace una operación se modifican las banderas (bits del registro de
estados y control) que indican las características del resultado.

\section{Números sin signo}

El valor más pequeño siempre es 0.

\vspace{1em}
Rango de número sin signo de 8 bits [0, 255], 9 bits [0, 511], 10 bits [0, 1023],
etc.

\vspace{1em}
Fórmula: $[0, 2^{n}-1]$ donde $n$ es el número de bits del número.

\section{Números con signo}

Los números con signo son representados con complemento a 2.

\vspace{1em}
Fórmula: $[-2^{n-1}, 2^{n-1}-1]$ donde $n$ es el número de bits del número.

\vspace{1em}
Cuando un número con signo se representa en complemento a 2, puede mostrar tanto
números negativos como positivos.

\vspace{1em}
Se sabe que es negativo si el MSB (Most Significant Bit) es 1 y que es
positivo si el MSB es 0.

\vspace{1em}
``Sacar'' o ``hacer'' el complemento a 2 significa que, si el número es positivo,
hacerlo negativo y viceversa.

Hacer el complemento a 2 de un número es invertir el signo de dicho número.

\vspace{1em}
Representar el complemento a 2 significa que, si el número es negativo,
representarlo negativo y viceversa.

\vspace{1em}
Ejemplo de números con signo de 8 bits:

\vspace{1em}
$1111,1111_{2}$: Negativo

$0101,1111_{2}$: Positivo

$1111_{2}$: Positivo

$1010_{2}$: Positivo

$1000,0000_{2}$: Negativo

\vspace{1em}
Los números en complemento a  2 son fáciles de determinar cuando son positivos,
pero cuando son negativos hay que hacer otros procedimientos.

\subsection{Complemento a 2 (método 1)}

Pasos:

\begin{enumerate}
	\item
		Invertir los bits
	\item
		Sumar una unidad
\end{enumerate}

\subsection{Complemento a 2 (método 2)}

El MSB tiene una ponderación negativa.

\section{Extensión de bit de signo}

\subsection{Números sin signo}

$0101_{2} = 5$

$00101_{2} = 5$

$000101_{2} = 5$

$0000000101_{2} = 5$

\subsection{Números con signo}

$110_{2} = -2$

$1110_{2} = -2$

$111110_{2} = -2$

$1111110_{2} = -2$

$111111110_{2} = -2$

\vspace{1em}
¿Qué número represetan los siguientes números en complemento a 2 si son de 10
bits?

\vspace{1em}
$a) 11,1111,1010_{2} = -6$

$b) 11,1110,0100_{2} = -28$

$c) 11,1111,1110_{2} = -2$

$d) 11,1000,0010_{2} = -126$

$e) 11,1101,1110_{2} = -34$

\vspace{1em}
Representar en complemento a 2 de 9 bits:

\vspace{1em}
$-9_{10} = 1,1111,0111_{2}$

$-17_{10} = 1,1110,1111_{2}$

$-8_{10} = 1,1111,1000_{2}$

$-20_{10} = 1,1110,1100_{2}$

\vspace{1em}
Antes de determinar un número hay que considerar lo siguiente:

\begin{enumerate}
	\item
		¿Están o no en complemento a 2?
	\item
		Si están en complemento a 2, ¿De cuántos bits son?
\end{enumerate}

\vspace{1em}
\textbf{Sobreflujo}.- Indica un cambio indebido de signo.

\newpage

\vspace{1em}
Ejemplos de operaciones donde se indican los cambios en las banderas:

\begin{figure}[h!]
	\centerline{\includegraphics[width=0.5\columnwidth]{flags.jpeg}}
	\caption{Cambio de banderas debido a las operaciones}
	\label{fig:flags}
\end{figure}

\vspace{1em}
\textbf{Disclaimer}: La finalidad de este documento es servir como apoyo de estudio.
El autor de la versión original de este documento no se hace responsable del
uso indebido del mismo.

\end{document}
